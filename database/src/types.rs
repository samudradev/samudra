//! Custom types

use sqlx::database::HasArguments;
use sqlx::encode::IsNull;
use sqlx::{Encode, Type};
use std::fmt::{Display, Formatter};
use std::{cmp::Ordering, fmt::Debug};

/// For values automatically generated by database.
///
/// It works similar to [Option] but conveys a clearer meaning.
#[derive(Clone, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
pub enum AutoGen<T> {
    /// The value is already provided by the database
    Known(T),
    /// The value is not yet provided by the database
    Unknown,
}

impl<T: Copy> Copy for AutoGen<T> {}

impl<T: PartialEq> PartialEq for AutoGen<T> {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::Known(l0), Self::Known(r0)) => l0 == r0,
            _ => core::mem::discriminant(self) == core::mem::discriminant(other),
        }
    }
}

impl<T: Debug> Debug for AutoGen<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Known(arg0) => f.debug_tuple("Known").field(arg0).finish(),
            Self::Unknown => write!(f, "Unknown"),
        }
    }
}

impl<T: Display> Display for AutoGen<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                AutoGen::Known(v) => {
                    format!("Known({})", v)
                }
                AutoGen::Unknown => {
                    "Unknown".to_string()
                }
            }
        )
    }
}

impl<T> From<AutoGen<T>> for Option<T> {
    fn from(value: AutoGen<T>) -> Option<T> {
        match value {
            AutoGen::Known(v) => Some(v),
            AutoGen::Unknown => None,
        }
    }
}

impl<T, DB: sqlx::Database> Encode<'_, DB> for AutoGen<T>
where
    T: for<'a> sqlx::Encode<'a, DB>,
    Self: Copy,
    Option<T>: for<'a> Encode<'a, DB>,
{
    fn encode_by_ref(&self, buf: &mut <DB as HasArguments<'_>>::ArgumentBuffer) -> IsNull {
        <Option<T> as Encode<'_, DB>>::encode_by_ref(&(*self).into(), buf)
    }
}

impl<T, DB: sqlx::Database> Type<DB> for AutoGen<T>
where
    T: Type<DB>,
{
    fn type_info() -> DB::TypeInfo {
        <Option<T> as Type<DB>>::type_info()
    }
}

impl<T: PartialOrd> PartialOrd for AutoGen<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        match (self, other) {
            (AutoGen::Known(a), AutoGen::Known(b)) => a.partial_cmp(b),
            (AutoGen::Known(_), AutoGen::Unknown) => Some(Ordering::Greater),
            (AutoGen::Unknown, AutoGen::Known(_)) => Some(Ordering::Less),
            (AutoGen::Unknown, AutoGen::Unknown) => Some(Ordering::Equal),
        }
    }
}

impl<T: ts_rs::TS> From<Option<T>> for AutoGen<T> {
    fn from(value: Option<T>) -> Self {
        match value {
            Some(t) => Self::Known(t),
            None => Self::Unknown,
        }
    }
}

/// `AutoGen<T>` acts like an option in JS/TS
impl<T: ts_rs::TS> ts_rs::TS for AutoGen<T> {
    fn name() -> String {
        <Option<T> as ts_rs::TS>::name()
    }

    fn name_with_type_args(args: Vec<String>) -> String {
        <Option<T> as ts_rs::TS>::name_with_type_args(args)
    }

    fn inline() -> String {
        <Option<T> as ts_rs::TS>::inline()
    }

    fn inline_flattened() -> String {
        <Option<T> as ts_rs::TS>::inline_flattened()
    }

    fn dependencies() -> Vec<ts_rs::Dependency> {
        <Option<T> as ts_rs::TS>::dependencies()
    }

    fn transparent() -> bool {
        <Option<T> as ts_rs::TS>::transparent()
    }
}
